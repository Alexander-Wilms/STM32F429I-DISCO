/**
  ******************************************************************************
 * @file    button.cpp
 * @author  Dr. Klaus Schaefer
 * @brief   pushbutton handler
 ******************************************************************************
 */

// [A]
// https://github.com/greiman/FreeRTOS-Arduino/issues/2
// Software-Timer müssen eingeschaltet werden
// #define configUSE_TIMERS 1 in FreeRTOSConfig.h

#include "common.h"
#include "uart.h"
// #include "stm324xg_eval.h"
// #include "stm32f4xx_hal_gpio.h"
// #include "stm32f4xx.h"
// #include "stm32f429i_discovery.h"
#include "stm32f429i_discovery_lcd.h"
#include "stm32f429i_discovery.h"

/** @brief  This function handles External line0 interrupt request. */
// Achtung: auf stm32f429i-discovery ist es EXTI0_IRQHandler, nicht EXTI15_10_IRQHandler
extern "C" void
EXTI0_IRQHandler(void)
{
	// ENTER_ISR;
	portBASE_TYPE TaskWoken = pdFALSE;

	/* reset both EXTI I/O interrupt latches,
	* as both buttons share the same interrupt
	* and we don't know which one triggered */
	__HAL_GPIO_EXTI_CLEAR_IT( KEY_BUTTON_PIN);

	/* disable further interrupts for a while */
	BSP_PB_Init (BUTTON_KEY, BUTTON_MODE_GPIO);

	/* trigger timer callback */
	// undefined reference to `xTimerGenericCommand'
	// Siehe [A]
	xTimerStartFromISR(de_bounce_timer, &TaskWoken);

	/* wake up task */
	xQueueSendFromISR( EXTIqueue, 0, &TaskWoken);

	/* preempt the active task if necessary */
	portEND_SWITCHING_ISR(TaskWoken);
}

/** @brief  This function enables the button interrupt
 *
 * The interrupt is re-enabled after waiting for a possible bouncing phase.
 * */
void de_bounce_callback(xTimerHandle)
{
	// once more: reset EXTI I/O interrupt latch
	__HAL_GPIO_EXTI_CLEAR_IT( KEY_BUTTON_PIN);
	BSP_PB_Init (BUTTON_KEY, BUTTON_MODE_EXTI);
}

//ROM char message[]="hello via UART\r\n";

extern QueueHandle_t TerminalQueue;

/** @brief  Task function responsible for LED blinking on pushbutton command */
void pushbutton_task(void *)
{
	/* Initialize queue */
	EXTIqueue = xQueueCreate( 10, 0); // actually a counting semaphore
	ASSERT( EXTIqueue != 0);

	/* Initialize timer */
	// Siehe [A]
	de_bounce_timer = xTimerCreate(0, 150, 0, 0, de_bounce_callback);
	ASSERT( de_bounce_timer != 0);

	/* Initialize queue */
	EXTIqueue = xQueueCreate( 10, 0); // actually a counting semaphore
	ASSERT( EXTIqueue != 0);

	/* Initialize USER Button with interrupt capability */
	BSP_PB_Init (BUTTON_KEY, BUTTON_MODE_EXTI);

	uint8_t buffer[2]={'a', 0};
	char message[]="hello via UART (Button)\r\n";
	extern uart uart3;

	while(1)
	{
		/* Indefinitely wait for pushbutton message */
		xQueueReceive(EXTIqueue, 0, portMAX_DELAY);
		xQueueSend( DisplayQueue, (void *) buffer, ( TickType_t ) 10 );
		xQueueSend( TerminalQueue, (void *) buffer, ( TickType_t ) 10 );
		buffer[0]++;
	}
}
